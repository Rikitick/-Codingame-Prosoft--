# Puzzles c сайта Codingame
Здесь находятся алгоритмические задачи с сайта Codingame для поступления в школу разработчиков Prosoft-системы

## Оглавление
- [Easy задачи](#easy-задачи)
  - [1D Spreadsheet](#1d-spreadsheet)
  - [Ascii art](#ascii-art)
  - [Defibrillators](#defibrillators)
  - [Encryption-decryption of Enigma machine](#encryption-decryption-of-enigma-machine)
  - [Ghost legs](#ghost-legs)
  - [Horse-racing duals](#horse-racing-duals)
  - [Island escape](#island-escape)
  - [Logic gates](#logic-gates)
  - [MIME type](#mime-type)
  - [Power of Thor - Episode 1](#power-of-thor-episode-1)
  - [Retro typewriter art](#retro-typewriter-art)
  - [Temperatures](#temperatures)
  - [The descent](#the-descent)
  - [The River I](#the-river-I)
  - [Unary](#unary)
- [Medium задачи](#medium-задачи)
- [Hard задачи](#hard-задачи)

## Easy задачи 
  ### 1D Spreadsheet
  [Код](/Puzzles/Easy/1d_spreadsheet.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/1d-spreadsheet)  
  
  __Идея__: Рекурсивно вычисляем каждую ячейку. Если встречаем ссылку на другую ячейку (например, $3) - сначала вычисляем ту ячейку, потом используем её значение  
  
  __Трудности__: Додуматься, как хранить значение и как использовать предыдущие (решил воспользоваться `struct`). Потом были проблемы с повторными вычислениями из-за чего вышибало дно рекурсии (решил это флагом `calculated`)  
  
  [К оглавлению](#оглавление)
  
  ### Ascii art
  [Код](/Puzzles/Easy/ascii_art.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/ascii-art)  
  
  __Идея__: Построчно сохранять символы алфавита, а потом построчно из алфавита брать те символы, которые относяться к буквам слова и сразу же выводить составленную строку  
  
  __Трудности__: В слове мог быть символ, которого нет в алфавите, а значит формула `c - 'A'` могла привести к ошибке `index was out of range`  
  
  [К оглавлению](#оглавление)

  ### Defibrillators
  [Код](/Puzzles/Easy/defibrillators.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/defibrillators)  
  
  __Идея__: Считать данные из `input`, сохранить только `Name`, `Longitude` и `Latitude` предварительно переведя в `double`, в цикле посчитать для каждого дифибрилятора расстояние до пользователя, выбрать минимальное и вывести название дифибрилятора с минимальным расстоянием  
  
  __Трудности__: В `input`-е `Longitude` и `Latitude` даются с `,`, из-за этого `stod` выдаёт ошибку  
  
  [К оглавлению](#оглавление)

  ### Encryption-decryption of Enigma machine
  [Код](/Puzzles/Easy/encryption_decryption_of_enigma_machine.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/encryptiondecryption-of-enigma-machine)  
  
  __Идея__: Описана в самой задаче. При декодировании просто сделать описанные действия в обратном порядке роторов  
  
  __Трудности__: Продумать формулу вычисления следующей буквы для кодирования и декодирования.  
  
  [К оглавлению](#оглавление)

  ### Ghost legs
  [Код](/Puzzles/Easy/ghost_legs.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/ghost-legs)  
  
  __Идея__: Спускаемся сверху вниз по каждой вертикальной линии. На каждой высоте проверяем, есть ли горизонтальные перемычки слева или справа. Если есть, переходим на соседнюю линию. Когда дошли до конца выводим начальную верхнюю метку и конечную нижнюю  
  
  __Трудности__: Пролетела со свистом :)  
  
  [К оглавлению](#оглавление)

  ### Horse-racing duals
  [Код](/Puzzles/Easy/horse-racing_duals.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/horse-racing-duals)  
  
  __Идея__: Жадный алгоритм. Сортируем силы лошадей по возрастанию и попарно перебираем, начиная с 1-ой, сохраняя минимальную разницу в переменную  
  
  __Трудности__: Пролетела со свистом :)  
  
  [К оглавлению](#оглавление)

  ### Island escape
  [Код](/Puzzles/Easy/island_escape.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/island-escape)  
  __Идея__: DFS (Обход графа в глубину). Начинаем с точки `{n/2, n/2}` и добавляем в массив вершин точки, у которых разница с текущей <= 1. Обязательно помечаем обработанные точки, чтобы не уйти в бесконечный цикл   
  
  __Трудности__: Вспомнить DFS XD  
  
  [К оглавлению](#оглавление)

  ### Logic gates
  [Код](/Puzzles/Easy/logic_gates.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/logic-gates)  
  __Идея__: Записываем входной сигнал в словарь (`key` - название, `value` - сигнал). Считываем запросы и посимвольно создаём новый сигнал, в зависимости от переданного `type` и предварительно заменив `-` и `_` на 1 и 0 соответственно  
  
  __Трудности__: Пролетела со свистом :)  
  
  [К оглавлению](#оглавление)

  ### MIME type
  [Код](/Puzzles/Easy/mime_type.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/mime-type)  
  
  __Идея__: Записываем входные элементы в неупорядоченный словарь (unordered_map<>, `key` - расширение, `value` - тип MIME) предварительно переписав символы расширения в нижний регистр. Потом идём по запросам, ищем в запросах правое вхождение точки с помощью `rfind()`, берём подстроку запроса с расширением с помощью `substr()`, переводим полученную подстроку в нижний регистр и находим это расширение в словаре. Если не нашли - выводим `UNKNOWN`  
  
  __Трудности__: Здесь я применил все свои возможные и невозможные познания в сфере оптимизации дабы пройти этот последний е***ий тест. Я сдел всё что можно было: резервировал память под словарь (`reserve()`), перемещал в словарь ссылки на строки входных данных вместо перемещения самих строк (`move(ext)`, `move(mt)`), оптимизировал стандартный ввод (`os_base::sync_with_stdio(false);`, `cin.tie(nullptr);`). Дело дошло до того, что я вручную попытался написать хеширование расширения в словарь, чтобы поиск MIME типа был по хешу (хотя я понимал, что в `map`, а уж тем более в `unordered_map`, поиск за O(1)). Ничего не помогало. По итогу я смирился и отправил так, как есть. И какого было моё удивление, когда мне показало, что моё решение зашло на 100%. ААААААААААА!!! Я убил на ошибку сайта 2 часа своей жизни и неисчислимое количесто нервов!  
  
  [К оглавлению](#оглавление)

  ### Power of Thor - Episode 1
  [Код](/Puzzles/Easy/power_of_thor-episode_1.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/power-of-thor-episode-1)  
  
  __Идея__: Здесь просто каждый раз считываем положение Тора и в зависимости от его положения и положения луча силы выводим нужное направление  
  
  __Трудности__: Проработать все случаи для правильного составления условий  
  
  [К оглавлению](#оглавление)

  ### Retro typewriter art
  [Код](/Puzzles/Easy/retro_typewriter_art.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/retro-typewriter-art)  
  
  __Идея__: Считываем строку и обрабатываем по пробелам: если встретился nl — вставляет перевод строки, иначе извлекает число и символ (с учётом спецсокращений) и добавляет в результат нужное количество символов  
  
  __Трудности__: Обработка случая, когда чанк состоит только из цифр (символ для картинки — последняя цифра)  
  
  [К оглавлению](#оглавление)

  ### Temperatures
  [Код](/Puzzles/Easy/temperatures.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/temperatures)  
  
  __Идея__: Проходим по каждой температуре выбираем минимальную по модулю температуру    
  
  __Трудности__: Могут быть такие случаи, что модули температур равны и в результат идёт отрицательное число, а по условию должно быть положительное  
  
  [К оглавлению](#оглавление)

  ### The descent
  [Код](/Puzzles/Easy/the_descent.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/the-descent)  
  
  __Идея__: Проходимся по каждой горе и выбираем гору с минимальной высотой  
  
  __Трудности__: Пролетела со свистом :)  
  
  [К оглавлению](#оглавление)

  ### The River I
  [Код](/Puzzles/Easy/the_river_I.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/the-river-i-)  
  
  __Идея__: Поочерёдно увеличиваем меньшую из двух рек (добавляя сумму её цифр), пока они не встретятся в общей точке  
  
  __Трудности__: Делать это в 2 часа ночи :(   
  
  [К оглавлению](#оглавление)

  ### Unary
  [Код](/Puzzles/Easy/unary.cpp)  
  [Задача](https://www.codingame.com/ide/puzzle/unary)  
  
  __Идея__: Преобразует каждый символ сообщения в двоичный код, затем кодирует последовательности одинаковых битов парами блоков: первый блок - тип бита (единица - 0, нуль - 00), второй блок — количество повторений в виде последовательности нулей  
  
  __Трудности__: Сначала я попытался проходить по каждому символу по отдельности, из-за этого на втором тесте я выводил на стыке символов не 0 000 (3 единицы), а 0 00 0 0 (2 единицы, 1 единица)  
  
  [К оглавлению](#оглавление)
  
## Medium задачи
  [К оглавлению](#оглавление)


## Hard задачи
  [К оглавлению](#оглавление)
